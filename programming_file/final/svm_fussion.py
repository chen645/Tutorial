# -*- coding: utf-8 -*-
"""SVM_fussion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SUZbxopNhMGrPUf2tKMdd48Iv6shFo02
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC

import numpy as np

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    import itertools
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

X1 = np.load('/content/drive/MyDrive/SVM_test/CNNHMM_predict.npy') #video predict
X11 = np.load('/content/drive/MyDrive/SVM_test/emotion_40frames_pred.npy') #video predict
X2 = np.load("/content/drive/MyDrive/SVM_test/speech_predict.npy") #speech predict
y = np.load("/content/drive/MyDrive/SVM_test/y_test.npy") #label
y = np.argmax(y, axis=-1)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn import svm
from sklearn.metrics import accuracy_score
from mlxtend.plotting import plot_decision_regions
from random import randint
data_count = len(X1)

X_true = np.zeros((data_count,2))
for i in range(data_count):
  X_true[i] = [X1[i],X2[i]]
from sklearn.decomposition import PCA
from sklearn.model_selection import KFold
from sklearn.metrics import confusion_matrix,classification_report
import time 
fold_num=10
kfold = KFold(n_splits=fold_num,shuffle=True,random_state=5576)
results=0
predict_result=[]
a = time.time()
for train,test in kfold.split(X_true):
  x_train,x_test=X_true[train],X_true[test]
  y_train,y_test=y[train],y[test]
  n_comp = 2

  
  cf = svm.SVC()
  cf.fit(x_train,y_train)
  y_pred = cf.predict(x_test)
 
  target_names = ['angry', 'disgust', 'fearful','happy','neautral','sad','surprised']
  
  cnf_matrix = confusion_matrix(y_test,y_pred)
  
  np.set_printoptions(precision=2)
  print(classification_report(y_test,y_pred,target_names=target_names))
  # Plot non-normalized confusion matrix
  
  result=accuracy_score(y_test,y_pred)
  results+=result
  predict_result.append(result)
  
plot_decision_regions(X=x_test, y=y_test,
                      clf=cf, 
                      legend=1)

# Update plot object with X/Y axis labels and Figure Title

plt.title('SVM Decision Region Boundary', size=16)  
print(time.time()-a)
print("平均測試率:(%.3f)"%(results/fold_num))
print(time.time()-a)  
for i in range(len(predict_result)):
  print("The %dth fold is %.3f"%(i,predict_result[i]))

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn import svm
from sklearn.metrics import accuracy_score
from sklearn import decomposition
from sklearn.decomposition import PCA

data_count = len(X1)
X_true = np.zeros((data_count,2))
for i in range(data_count):
  X_true[i] = [X11[i],X2[i]]

from sklearn.model_selection import KFold
from sklearn.metrics import confusion_matrix,classification_report
import time 
kfold = KFold(n_splits=5,shuffle=True,random_state=1)
results=0
a = time.time()
for train,test in kfold.split(X_true):
  x_train,x_test=X_true[train],X_true[test]
  y_train,y_test=y[train],y[test]
  n_comp = 2

  pca = PCA(n_comp)  

  # finding pca axes
  pca.fit(x_train)
  # projecting training data onto pca axes
  x_train_proj = pca.transform(x_train)
  # projecting test data onto pca axes
  x_test_proj = pca.transform(x_test)
  cf = svm.SVC()
  cf.fit(x_train_proj,y_train)
  y_pred1 = cf.predict(x_test_proj)
 
  target_names = ['angry', 'disgust', 'fearful','happy','neautral','sad','surprised']
  print(classification_report(y_test, y_pred1))
  print(confusion_matrix(y_test,y_pred1))
  results+=accuracy_score(y_test,y_pred1)
print(time.time()-a)
print("平均測試率:",results/5)
print(time.time()-a)

